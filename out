
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: tests_specsynth/case6.spec
 EXPLORED goal Number :: 0
 EXPLORED Max path length :: 3stexcwhitespace var: slen
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
semicolon
stexcwhitespace var: slist
whitespace colon
whitespace var: list
whitespace colon
whitespace var: bool
semicolon
stexcwhitespace var: shd
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
semicolon
var: subs
whitespace colon
whitespace lparen
var: n
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
whitespace lessthanopwhitespace int: 0
rbrace
rcurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: v
whitespace equalopwhitespace var: n
whitespace ar-minuswhitespace int: 1
rcurly
semicolon
var: gt
whitespace colon
whitespace lparen
var: n1
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
lessthanopint: 0
rbrace
rcurly
rparen
whitespace arrow
whitespace lparen
var: n2
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
lessthanopint: 0
rbrace
rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lbrace
var: n1
lessthanopvar: n2
rbrace
whitespace conjwhitespace whitespace lbrace
var: v
equalopfalserbrace
whitespace iffwhitespace notwhitespace lbrace
var: n1
lessthanopvar: n2
rbrace
rcurly
semicolon
var: nil
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace var: slist
whitespace lparen
var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: int_gen
whitespace colon
whitespace lparen
var: n3
colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
whitespace lessthanopwhitespace var: n3
rbrace
rcurly
semicolon
whitespace var: sizecheck
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lbrace
var: s
equalopint: 0
rbrace
whitespace conjwhitespace whitespace lbrace
var: v
equalopfalserbrace
whitespace iffwhitespace lbrace
var: s
lessthanopint: 0
rbrace
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace whitespace lparen
var: xs
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace var: slist
whitespace lparen
var: v
rparen
whitespace equalopwhitespace truewhitespace rcurly
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace whitespace lparen
whitespace lparen
notwhitespace lparen
var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace int: 0
rparen
rparen
whitespace implieswhitespace var: shd
whitespace lparen
var: xs
rparen
whitespace lessthanopwhitespace var: x
rparen
whitespace conjwhitespace lparen
var: shd
whitespace lparen
var: xs
rparen
whitespace lessthanopwhitespace var: x
rparen
whitespace implieswhitespace whitespace lparen
var: slist
whitespace lparen
var: v
rparen
whitespace equalopwhitespace truewhitespace conjwhitespace whitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: slen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
whitespace conjwhitespace var: shd
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: x
rparen
rcurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
whitespace lessthanopint: 0
rbrace
whitespace disjwhitespace lbrace
var: v
equalopint: 0
rbrace
rcurly
rparen
whitespace arrow
whitespace whitespace lparen
var: x0
whitespace colon
var: int
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace var: slist
whitespace lparen
var: v
rparen
whitespace equalopwhitespace truewhitespace whitespace conjwhitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: s
whitespace whitespace conjwhitespace lparen
var: slen
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace int: 0
whitespace whitespace implieswhitespace whitespace var: shd
whitespace lparen
var: v
rparen
whitespace lessthanopwhitespace var: x0
rparen
whitespace rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name subs : 
 params :
 Type  Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))} 
 Assume false
 name gt : 
 params :
 Type  Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c } 
 Assume false
 name nil : 
 params :
 Type {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } 
 Assume false
 name int_gen : 
 params :
 Type  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3} 
 Assume false
 name sizecheck : 
 params :
 Type  Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c } 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( s : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c };  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( s : {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
 sizecheck :  Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
 int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
 nil : {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }
 gt :  Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }
 subs :  Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}
 INITIAL SIGMA 
 
 TypeNames 
 
 Qualifiers 
 
 Qual slen :  :-> Ty_alphalist :-> Ty_int
 Qual slist :  :-> Ty_alphalist :-> Ty_bool
 Qual shd :  :-> Ty_alphalist :-> Ty_int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , s:{v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }, x0:{var_v3:Ty_int | true} -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Decreasing Measure s
 Decreasing Type {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }
 Calculated Decreasing Predicate s > v
 Calculated Decreased Goal Type  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Show :: List Ty_int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 iSynthesize If-THEN-ELSE {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 iSynthesize Boolean {var_v4:Ty_bool | true}
 esynthesizeScalar for {var_v4:Ty_bool | true}
  Enumeration for 
 spec 
 {var_v4:Ty_bool | true}
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 sizecheck, 
 gt
 ############################################################
  Trying Pure Component sizecheck
  *************** Trying Arrow Component ************sizecheck :  Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  *************** Synthesizing Args ei : ti for ************sizecheck
 ##################################################################################
  Synthesizing the 1th argument for Function sizecheck
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v1:Ty_int | true}
  Enumeration for 
 spec 
 {var_v1:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                        
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}             
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                        
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}             
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true} 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Typechecking apply int_gen  (, x0 )
 Against {var_v1:Ty_int | true}
 Argument x0 :: {var_v3:Ty_int | true} | true                       
  Show *************** TypeChecking Succsessful {v:Ty_int | v > x0}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv0 = apply int_gen  (, x0 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Typechecking apply int_gen  (, s )
 Against {var_v1:Ty_int | true}
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                        
  Show *************** TypeChecking Succsessful {v:Ty_int | v > s}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv1 = apply int_gen  (, s )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s} 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for sizecheck 4
 # of Possible Argument Options for sizecheck 4
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Possible Arg Options 
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 Apply Single Argument Case : f (ei) Case sizecheck
  Case : f (ei) Case sizecheck x0
 Finding Already seen tree for apply sizecheck  (, x0 )
 Typechecking apply sizecheck  (, x0 )
 Against {var_v4:Ty_bool | true}
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                     
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv2 = apply sizecheck  (, x0 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case sizecheck s
 Finding Already seen tree for apply sizecheck  (, s )
 Typechecking apply sizecheck  (, s )
 Against {var_v4:Ty_bool | true}
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                        
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv3 = apply sizecheck  (, s )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case sizecheck _lbv1
 Finding Already seen tree for apply sizecheck  (, _lbv1 )
 Typechecking apply sizecheck  (, _lbv1 )
 Against {var_v4:Ty_bool | true}
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                        
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv4 = apply sizecheck  (, _lbv1 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Case : f (ei) Case sizecheck _lbv0
 Finding Already seen tree for apply sizecheck  (, _lbv0 )
 Typechecking apply sizecheck  (, _lbv0 )
 Against {var_v4:Ty_bool | true}
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                               
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 let _lbv5 = apply sizecheck  (, _lbv0 )
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Show :: iSynthesize Boolean Successful _lbv5
 Show :: iSynthesize Boolean Successful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v5 = true
 	 , DoubleImpl 
 var_v5 = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 var_v5 = false
  _lbv0 > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  Enumeration for 
 spec 
 {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                           
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                  
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                       
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
 ############################################################
  Trying Pure Component subs
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | v > 0}
  Enumeration for 
 spec 
 {v:Ty_int | v > 0}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                       
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                 
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                 
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for subs 1
 # of Possible Argument Options for subs 1
 Possible Arg Options 
 EI _lbv1
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs _lbv1
 Finding Already seen tree for apply subs  (, _lbv1 )
 Typechecking apply subs  (, _lbv1 )
 Against {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply subs  (, _lbv1 )
  ###################################################
  The Choice of Function subs Was Ill Fated Try Next Choice of function
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                            
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for goal 12
 # of Possible Argument Options for goal 12
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv1
 EI x0
 Possible Arg Options 
 EI _lbv1
 EI s
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI x0
 Possible Arg Options 
 EI _lbv0
 EI s
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                  
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), s )
 Typechecking apply goal  (, apply int_gen  (, s ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), s )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                  
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), s )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), s )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                            
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                           
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                  
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                       
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                            
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                  
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                       
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                            
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                           
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 4
 # of Possible Argument Options for cons 4
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                           
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 6
 # of Possible Argument Options for cons 6
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                           
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 Failed Synthesizing any True Branch exp for the selected guard_lbv5
 Try Next guard
 Show :: iSynthesize Boolean Successful _lbv4
 Show :: iSynthesize Boolean Successful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v6 = true
 	 , DoubleImpl 
 var_v6 = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 var_v6 = false
  _lbv1 > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  Enumeration for 
 spec 
 {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                  
 Show :: Found a Few Macthing Scalars 
 True Branch :: Successfully Synthesisized
 *********************************************
 if apply sizecheck  (, apply int_gen  (, s ) )
 	 then 
 ***********
 nil
 ************If Else False Branch**************
 *********************************************
 False Branch :: Trying False Branch
 Show :: Synthesizing the false branch
 Show :: False Predicate 
 	 Conj <c var_v6 = false
 	 , DoubleImpl 
 var_v6 = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 var_v6 = false
  _lbv1 > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  Enumeration for 
 spec 
 {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                  
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                         
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                              
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                   
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                   
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
 ############################################################
  Trying Pure Component subs
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | v > 0}
  Enumeration for 
 spec 
 {v:Ty_int | v > 0}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                              
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                   
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                        
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                        
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for subs 1
 # of Possible Argument Options for subs 1
 Possible Arg Options 
 EI _lbv1
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs _lbv1
 Finding Already seen tree for apply subs  (, _lbv1 )
 Typechecking apply subs  (, _lbv1 )
 Against {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply subs  (, _lbv1 )
  ###################################################
  The Choice of Function subs Was Ill Fated Try Next Choice of function
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                   
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                   
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for goal 12
 # of Possible Argument Options for goal 12
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv1
 EI x0
 Possible Arg Options 
 EI _lbv1
 EI s
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI x0
 Possible Arg Options 
 EI _lbv0
 EI s
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                                         
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), s )
 Typechecking apply goal  (, apply int_gen  (, s ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), s )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                                         
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), s )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), s )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                   
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                   
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                  
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                         
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                              
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                   
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                   
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                   
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                   
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                         
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                              
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                   
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                   
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                  
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 4
 # of Possible Argument Options for cons 4
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                  
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 6
 # of Possible Argument Options for cons 6
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                  
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 Show :: Failed Synthesis of any False Branch 
 Show :: iSynthesize Boolean Successful _lbv3
 Show :: iSynthesize Boolean Successful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v7 = true
 	 , DoubleImpl 
 var_v7 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v7 = false
  s > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  Enumeration for 
 spec 
 {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                         
 Show :: Found a Few Macthing Scalars 
 True Branch :: Successfully Synthesisized
 *********************************************
 if apply sizecheck  (, s )
 	 then 
 ***********
 nil
 ************If Else False Branch**************
 *********************************************
 False Branch :: Trying False Branch
 Show :: Synthesizing the false branch
 Show :: False Predicate 
 	 Conj <c var_v7 = false
 	 , DoubleImpl 
 var_v7 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v7 = false
  s > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  Enumeration for 
 spec 
 {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                         
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                     
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                          
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                          
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
 ############################################################
  Trying Pure Component subs
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | v > 0}
  Enumeration for 
 spec 
 {v:Ty_int | v > 0}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                     
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                          
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                               
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                               
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for subs 1
 # of Possible Argument Options for subs 1
 Possible Arg Options 
 EI _lbv1
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs _lbv1
 Finding Already seen tree for apply subs  (, _lbv1 )
 Typechecking apply subs  (, _lbv1 )
 Against {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply subs  (, _lbv1 )
  ###################################################
  The Choice of Function subs Was Ill Fated Try Next Choice of function
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                          
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                          
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for goal 12
 # of Possible Argument Options for goal 12
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv1
 EI x0
 Possible Arg Options 
 EI _lbv1
 EI s
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI x0
 Possible Arg Options 
 EI _lbv0
 EI s
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                                                                
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), s )
 Typechecking apply goal  (, apply int_gen  (, s ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), s )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                                                                
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), s )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), s )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                          
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                          
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                         
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                     
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                          
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                          
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                          
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                          
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                     
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                          
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                          
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                         
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 4
 # of Possible Argument Options for cons 4
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                         
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 6
 # of Possible Argument Options for cons 6
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                              
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                         
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 Show :: Failed Synthesis of any False Branch 
 Show :: iSynthesize Boolean Successful _lbv2
 Show :: iSynthesize Boolean Successful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v8 = true
 	 , DoubleImpl 
 var_v8 = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 var_v8 = false
  x0 > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  Enumeration for 
 spec 
 {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                                                
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                                       
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                                 
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                                 
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
 ############################################################
  Trying Pure Component subs
  *************** Trying Arrow Component ************subs :  Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 ##################################################################################
  Synthesizing the 1th argument for Function subs
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | v > 0}
  Enumeration for 
 spec 
 {v:Ty_int | v > 0}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                                 
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                      
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                      
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for subs 2
 # of Possible Argument Options for subs 2
 Possible Arg Options 
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 Apply Single Argument Case : f (ei) Case subs
  Case : f (ei) Case subs _lbv1
 Finding Already seen tree for apply subs  (, _lbv1 )
 Typechecking apply subs  (, _lbv1 )
 Against {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                                                 
  FAILED Typechecking PURE APP For apply subs  (, _lbv1 )
  Case : f (ei) Case subs _lbv0
 Finding Already seen tree for apply subs  (, _lbv0 )
 Typechecking apply subs  (, _lbv0 )
 Against {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                                                 
  FAILED Typechecking PURE APP For apply subs  (, _lbv0 )
  ###################################################
  The Choice of Function subs Was Ill Fated Try Next Choice of function
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                 
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                 
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for goal 12
 # of Possible Argument Options for goal 12
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv1
 EI x0
 Possible Arg Options 
 EI _lbv1
 EI s
 Possible Arg Options 
 EI _lbv1
 EI _lbv1
 Possible Arg Options 
 EI _lbv1
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Possible Arg Options 
 EI _lbv0
 EI x0
 Possible Arg Options 
 EI _lbv0
 EI s
 Possible Arg Options 
 EI _lbv0
 EI _lbv1
 Possible Arg Options 
 EI _lbv0
 EI _lbv0
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv1 ), s )
 Typechecking apply goal  (, apply int_gen  (, s ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), s )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv1 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, s ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv1 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv1 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), x0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), x0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument x0 :: {var_v3:Ty_int | true} | true                                                                                                                                                                                                                                                       
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), x0 )
 Finding Already seen tree for apply goal  (, _lbv0 ), s )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), s )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d                                                                                                                                                                                                                                                                   
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), s )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv1 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, s ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv1 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv1 )
 Finding Already seen tree for apply goal  (, _lbv0 ), _lbv0 )
 Typechecking apply goal  (, apply int_gen  (, x0 ) ), apply int_gen  (, x0 ) )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply goal  (, _lbv0 ), _lbv0 )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0                                                                                                                                                                                                                                                            
  FAILED Typechecking PURE APP For apply goal  (, _lbv0 ), _lbv0 )
  ###################################################
  The Choice of Function goal Was Ill Fated Try Next Choice of function
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                 
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                 
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 int_gen, 
 subs
 ############################################################
  Trying Pure Component int_gen
  *************** Trying Arrow Component ************int_gen :  Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}
  *************** Synthesizing Args ei : ti for ************int_gen
 ##################################################################################
  Synthesizing the 1th argument for Function int_gen
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}
 ################################################
 Skipping Variable _lbv0 As Outer Function Call is int_gen
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}
 ################################################
 Skipping Variable _lbv1 As Outer Function Call is int_gen
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for int_gen 2
 # of Possible Argument Options for int_gen 2
 Possible Arg Options 
 EI x0
 Possible Arg Options 
 EI s
 Apply Single Argument Case : f (ei) Case int_gen
  Case : f (ei) Case int_gen x0
 Finding Already seen tree for apply int_gen  (, x0 )
 Found _lbv0
  Case : f (ei) Case int_gen s
 Finding Already seen tree for apply int_gen  (, s )
 Found _lbv1
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                                                
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 ############################################################
  Trying Pure Component goal
  *************** Trying Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
  *************** Synthesizing Args ei : ti for ************goal
 ##################################################################################
  Synthesizing the 1th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c }
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                                       
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                                            
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                                 
 
 FaileD the subtype check T_vi <: T_goal
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                                 
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found in Environment, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function goal
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v3:Ty_int | true}
  Enumeration for 
 spec 
 {var_v3:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                 
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                 
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Synthesizing Args ei : Failed for some  arg
 ############################################################
  Trying Pure Component cons
  *************** Trying Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }
  *************** Synthesizing Args ei : ti for ************cons
 ##################################################################################
  Synthesizing the 1th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Scalar Term s
 
 Type of the Scalar Term {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }                                                                                                                                                                                                                                                       
 
 Enumerating a Scalar Term x0
 
 Type of the Scalar Term {var_v3:Ty_int | true}                                                                                                                                                                                                                                            
 
 Enumerating a Scalar Term _lbv0
 
 Type of the Scalar Term {v:Ty_int | v > x0}                                                                                                                                                                                                                                                 
 
 Enumerating a Scalar Term _lbv1
 
 Type of the Scalar Term {v:Ty_int | v > s}                                                                                                                                                                                                                                                 
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
  Synthesizing the 2th argument for Function cons
  Trying Arguments in Scalars 
 esynthesizeScalar for {v:Ty_alphalist | (slist)(v) = (true)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slist)(v) = (true)}
 
 Enumerating a Scalar Term nil
 
 Type of the Scalar Term {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }                                                                                                                                                                                                                                                
 Show :: Found a Few Macthing Scalars 
  Next Trying Arguments of the form f (ei...) 
  Pure Fun Application: esynthesizePureApp 
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 4
 # of Possible Argument Options for cons 4
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | (slist)(v) = (true)}
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                                
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 ##################################################################################
 Gamma Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c 
 Disj <d  v > 0
 	,   v = 0>d 
 	 , s > v >c } ) ->  Arrow ( ( x0 : {var_v3:Ty_int | true} ) -> {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s1)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {v:Ty_alphalist | (slist)(v) = (true)} ) -> {v:Ty_alphalist | 
 	 Conj <c 
 	 Impl < Negation (slen)(v) ==(0)
 	 (shd)(xs) > (x) >
 	 , 
 	 Impl < (shd)(xs) > (x)
 	 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==((slen)(xs) + (1))
 	 , (shd)(v) > (x) >c  >c  > >c }  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 int_gen --->   Arrow ( ( n3 : {var_v0:Ty_int | true} ) -> {v:Ty_int | v > n3}  
 nil --->  {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c }  
 gt --->   Arrow ( ( n1 : {v:Ty_int | v > 0} ) ->  Arrow ( ( n2 : {v:Ty_int | v > 0} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c n1 > n2
 	 , DoubleImpl 
 v = false
  Negation n1 > n2 >c }  
 subs --->   Arrow ( ( n : {v:Ty_int | v > 0} ) -> {v:Ty_int | (v) ==((n) -- (1))}  
 s --->  {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d }  
 x0 --->  {var_v3:Ty_int | true}  
 _lbv0 --->  {v:Ty_int | v > x0}  
 _lbv1 --->  {v:Ty_int | v > s}  
 _lbv2 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c }  
 _lbv3 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _lbv4 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 _lbv5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv0 = 0
 	 , DoubleImpl 
 v = false
  _lbv0 > 0 >c }  
 var_v6 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c _lbv1 = 0
 	 , DoubleImpl 
 v = false
  _lbv1 > 0 >c }  
 var_v7 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 var_v8 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c x0 = 0
 	 , DoubleImpl 
 v = false
  x0 > 0 >c } 
  *************** Successfully Synthesized Args ei Forall i 
 # of Possible Argument Options for cons 6
 # of Possible Argument Options for cons 6
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Possible Arg Options 
 EI x0
 EI nil
 Possible Arg Options 
 EI s
 EI nil
 Possible Arg Options 
 EI _lbv1
 EI nil
 Possible Arg Options 
 EI _lbv0
 EI nil
 Show f (ei, e2, ....en) Case
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
 Finding Already seen tree for apply cons  (, x0 ), nil )
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, x0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument x0 :: {var_v3:Ty_int | true} | true
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                     
  FAILED Typechecking PURE APP For apply cons  (, x0 ), nil )
 Finding Already seen tree for apply cons  (, s ), nil )
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, s ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument s :: {v:Ty_int | 
 Disj <d  v > 0
 	,   v = 0>d } | 
 Disj <d  s > 0
 	,   s = 0>d 
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                                
  FAILED Typechecking PURE APP For apply cons  (, s ), nil )
 Finding Already seen tree for apply cons  (, _lbv1 ), nil )
 Typechecking apply cons  (, apply int_gen  (, s ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv1 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv1 :: {v:Ty_int | v > s} | _lbv1 > s
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply cons  (, _lbv1 ), nil )
 Finding Already seen tree for apply cons  (, _lbv0 ), nil )
 Typechecking apply cons  (, apply int_gen  (, x0 ) ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Typechecking apply cons  (, _lbv0 ), nil )
 Against {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , 
 	 Conj <c (slen)(v) ==(s)
 	 , 
 	 Impl < (slen)(v) > (0)
 	 (shd)(v) > (x0) > >c  >c }
 Argument _lbv0 :: {v:Ty_int | v > x0} | _lbv0 > x0
 Argument nil :: {v:Ty_alphalist | 
 	 Conj <c (slist)(v) = (true)
 	 , (slen)(v) ==(0) >c } | 
 	 Conj <c (slist)(nil) = (true)
 	 , (slen)(nil) ==(0) >c                                                                                                                                                                                                                                                          
  FAILED Typechecking PURE APP For apply cons  (, _lbv0 ), nil )
  ###################################################
  The Choice of Function cons Was Ill Fated Try Next Choice of function
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 Failed Synthesizing any True Branch exp for the selected guard_lbv2
 Try Next guard
  If then else Failed :: Try CDCL without subdivision
 
 
 let _lbv0 = apply int_gen  (, x0 ) 
 in 
 let _lbv1 = apply int_gen  (, s ) 
 in 
 let _lbv2 = apply sizecheck  (, x0 ) 
 in 
 let _lbv3 = apply sizecheck  (, s ) 
 in 
 let _lbv4 = apply sizecheck  (, _lbv1 ) 
 in 
 let _lbv5 = apply sizecheck  (, _lbv0 ) 
 in _lbv5
 Synthesis returned witout result