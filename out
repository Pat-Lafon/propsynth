
  EXPLORED Args.parser output 
 EXPLORED learningOn  true
 EXPLORED bidirectionality  true
 EXPLORED effect-filter  false
 EXPLORED specfile :: tests_specsynth/case4.spec
 EXPLORED goal Number :: 0stexcwhitespace var: slen
whitespace colon
whitespace var: list
whitespace colon
whitespace var: int
semicolon
var: subs
whitespace colon
whitespace lparen
var: n1
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace var: v
whitespace equalopwhitespace var: n1
whitespace ar-minuswhitespace int: 1
rcurly
semicolon
var: nil
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace int: 0
rcurly
semicolon
var: sizecheck
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace whitespace lcurly
var: v
whitespace colon
whitespace var: bool
whitespace pipe
whitespace lbrace
var: v
equaloptruerbrace
whitespace iffwhitespace lbrace
var: s
equalopint: 0
rbrace
whitespace conjwhitespace lbrace
var: v
equalopfalserbrace
whitespace iffwhitespace lbrace
var: s
whitespace lessthanopwhitespace int: 0
rbrace
rcurly
semicolon
var: cons
whitespace colon
whitespace lparen
var: x
whitespace colon
whitespace var: int
rparen
whitespace arrow
whitespace lparen
var: xs
whitespace colon
whitespace var: list
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace var: slen
lparen
var: v
rparen
whitespace equalopwhitespace var: slen
whitespace lparen
var: xs
rparen
whitespace pluswhitespace int: 1
rcurly
semicolon
whitespace var: goal
whitespace colon
whitespace lparen
var: s
whitespace colon
whitespace lcurly
var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
rparen
whitespace arrow
whitespace lcurly
var: v
whitespace colon
whitespace var: list
whitespace pipe
whitespace var: slen
whitespace lparen
var: v
rparen
whitespace equalopwhitespace var: s
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name subs : 
 params :
 Type  Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))} 
 Assume false
 name nil : 
 params :
 Type {v:Ty_alphalist | (slen)(v) ==(0)} 
 Assume false
 name sizecheck : 
 params :
 Type  Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c } 
 Assume false
 name cons : 
 params :
 Type  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))} 
 Assume false
 name goal : 
 params :
 Type  Arrow ( ( s : {v:Ty_int | true} ) -> {v:Ty_alphalist | (slen)(v) ==(s)};  Formulas  }
 INITIAL GAMMA 
 
 goal :  Arrow ( ( s : {v:Ty_int | true} ) -> {v:Ty_alphalist | (slen)(v) ==(s)}
 cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}
 sizecheck :  Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
 nil : {v:Ty_alphalist | (slen)(v) ==(0)}
 subs :  Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}
 INITIAL SIGMA 
 
 TypeNames 
 
 Qualifiers 
 
 Qual slen :  :-> Ty_alphalist :-> Ty_int
 Show ***********Calling S-FUNC synthesize***************
 Show Uncurried , s:{v:Ty_int | true} -> {v:Ty_alphalist | (slen)(v) ==(s)}
 Decreasing Measure s
 Decreasing Type {v:Ty_int | true}
 Calculated Decreasing Predicate s > v
 Calculated Decreased Goal Type  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}
 Show Trying :: Top-level Match
 Show :: Synthesize Match {v:Ty_alphalist | (slen)(v) ==(s)}
 Show :: List Ty_int
 Show :: Non List Case
 Match-case failed :: Try Top-level If-then-else 
 iSynthesize If-THEN-ELSE {v:Ty_alphalist | (slen)(v) ==(s)}
 Show :: iSynthesize Boolean {var_v4:Ty_bool | true}
 esynthesizeScalar for {var_v4:Ty_bool | true}
  Enumeration for 
 spec 
 {var_v4:Ty_bool | true}
 >>>>>>>>>>>>>>>>>> No Scalar found, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 sizecheck
 Show Pure Component sizecheck
  *************** Arrow Component ************sizecheck :  Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  *************** Synthesizing Args ei : ti for ************sizecheck
 esynthesizeScalar for {var_v1:Ty_int | true}
  Enumeration for 
 spec 
 {var_v1:Ty_int | true}
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
 Show :: Found a Few Macthing Scalars 
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | true} 
 s 
 }
 Possible Argument Options 
 Next Possible Args 
 EI s
 Apply Single Argument Case : f (ei) Case sizecheck
 Typechecking apply sizecheck  (, s )
 Against {var_v4:Ty_bool | true}
 Argument s :: {v:Ty_int | true} | true
 AppType {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 v --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , true >c 
 	 , true >c 
 	 , DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c  >c 
 	 ------------------------------
 
        	 CONS => true 
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 v --->  Ty_bool 
 	 ANTE Base v = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base v = false <=> Base s > 0 
 	 ------------------------

	 CONS True
 
VC_END                       
  Show *************** TypeChecking Succsessful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
 Show :: iSynthesize Boolean Successful apply sizecheck  (, s )
 Show :: iSynthesize Boolean Successful {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }
  *********************Synthesizing the True branch*******************
 Show :: True Predicate 
 	 Conj <c var_v5 = true
 	 , DoubleImpl 
 var_v5 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v5 = false
  s > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | (slen)(v) ==(s)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slen)(v) ==(s)}
 
 Enumerating a Pure Term nil
 
 Type of the Pure Term {v:Ty_alphalist | (slen)(v) ==(0)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 subs --->  Function type  
 s --->  Ty_int  
 var_v5 --->  Ty_bool  
 nil --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Base var_v5 = true AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 AND 
 	 Rel (slen)(nil) ==(0) 
 	 ------------------------

	 CONS Rel (slen)(nil) ==(s)
 
VC_END                             
 Show :: Found a Few Macthing Scalars 
 Solution { 
{v:Ty_alphalist | (slen)(v) ==(0)} 
 nil 
 }
 True Branch :: Successfully Synthesisized
 False Branch :: Trying False Branch
 Show :: Synthesizing the false branch
 Show :: False Predicate 
 	 Conj <c var_v5 = false
 	 , DoubleImpl 
 var_v5 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v5 = false
  s > 0 >c  >c 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | (slen)(v) ==(s)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slen)(v) ==(s)}
 
 Enumerating a Pure Term nil
 
 Type of the Pure Term {v:Ty_alphalist | (slen)(v) ==(0)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 subs --->  Function type  
 s --->  Ty_int  
 var_v5 --->  Ty_bool  
 nil --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 AND 
 	 Rel (slen)(nil) ==(0) 
 	 ------------------------

	 CONS Rel (slen)(nil) ==(s)
 
VC_END                             
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 Show Pure Component goal
  *************** Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}
  *************** Synthesizing Args ei : ti for ************goal
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c }
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 var_v5 --->  Ty_bool  
 s --->  Ty_int 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 
 	 ------------------------

	 CONS Base s > s
 
VC_END                                  
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs
 Show Pure Component subs
  *************** Arrow Component ************subs :  Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 var_v5 --->  Ty_bool  
 s --->  Ty_int 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 
 	 ------------------------

	 CONS True
 
VC_END                             
 Show :: Found a Few Macthing Scalars 
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | true} 
 s 
 }
 Possible Argument Options 
 Next Possible Args 
 EI s
 Apply Single Argument Case : f (ei) Case subs
 Typechecking apply subs  (, s )
 Against {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c }
 Argument s :: {v:Ty_int | true} | true
 AppType {v:Ty_int | (v) ==((s) -- (1))}
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 v --->  {v:Ty_int | (v) ==((s) -- (1))}  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , 
 	 Conj <c true
 	 , 
 	 Conj <c var_v5 = false
 	 , DoubleImpl 
 var_v5 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v5 = false
  s > 0 >c  >c  >c  >c 
 	 , true >c 
 	 , (v) ==((s) -- (1)) >c 
 	 ------------------------------
 
        	 CONS => 
 	 Conj <c true
 	 , s > v >c  
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 var_v5 --->  Ty_bool  
 v --->  Ty_int 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 AND 
 	 Rel (v) ==((s) -- (1)) 
 	 ------------------------

	 CONS Base s > v
 
VC_END                                  
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((s) -- (1))}
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | (v) ==((s) -- (1))} 
 apply subs  (, s ) 
 }
 Possible Argument Options 
 Next Possible Args 
 EI apply subs  (, s )
 Apply Single Argument Case : f (ei) Case goal
 Typechecking apply goal  (, _bv0 )
 Against {v:Ty_alphalist | (slen)(v) ==(s)}
 Argument _bv0 :: {v:Ty_int | (v) ==((s) -- (1))} | (_bv0) ==((s) -- (1))
 AppType {v:Ty_alphalist | (slen)(v) ==(_bv0)}
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _bv0 --->  {v:Ty_int | (v) ==((s) -- (1))}  
 v --->  {v:Ty_alphalist | (slen)(v) ==(_bv0)}  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , 
 	 Conj <c true
 	 , 
 	 Conj <c var_v5 = false
 	 , DoubleImpl 
 var_v5 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v5 = false
  s > 0 >c  >c  >c  >c 
 	 , (_bv0) ==((s) -- (1)) >c 
 	 , (slen)(v) ==(_bv0) >c 
 	 ------------------------------
 
        	 CONS => (slen)(v) ==(s) 
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 var_v5 --->  Ty_bool  
 _bv0 --->  Ty_int  
 v --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 AND 
 	 Rel (_bv0) ==((s) -- (1)) AND 
 	 Rel (slen)(v) ==(_bv0) 
 	 ------------------------

	 CONS Rel (slen)(v) ==(s)
 
VC_END                             
  FAILED Typechecking PURE APP For apply goal  (, _bv0 )
 Show Pure Component cons
  *************** Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}
  *************** Synthesizing Args ei : ti for ************cons
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 var_v5 --->  Ty_bool  
 s --->  Ty_int 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 
 	 ------------------------

	 CONS True
 
VC_END                             
 Show :: Found a Few Macthing Scalars 
 esynthesizeScalar for {var_v3:Ty_alphalist | true}
  Enumeration for 
 spec 
 {var_v3:Ty_alphalist | true}
 
 Enumerating a Pure Term nil
 
 Type of the Pure Term {v:Ty_alphalist | (slen)(v) ==(0)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 subs --->  Function type  
 s --->  Ty_int  
 var_v5 --->  Ty_bool  
 nil --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 AND 
 	 Rel (slen)(nil) ==(0) 
 	 ------------------------

	 CONS True
 
VC_END                             
 Show :: Found a Few Macthing Scalars 
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | true} 
 s 
 }
  
 Show Argij { 
{v:Ty_alphalist | (slen)(v) ==(0)} 
 nil 
 }
 Possible Argument Options 
 Next Possible Args 
 EI s
 EI nil
 Show f (ei, e2, ....en) Case
 Typechecking apply cons  (, _bv1 ), _bv2 )
 Against {v:Ty_alphalist | (slen)(v) ==(s)}
 Argument _bv1 :: {v:Ty_int | true} | true
 Argument _bv2 :: {v:Ty_alphalist | (slen)(v) ==(0)} | (slen)(_bv2) ==(0)
 AppType {v:Ty_alphalist | (slen)(v) ==((slen)(_bv2) + (1))}
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 var_v5 --->  {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 _bv1 --->  {v:Ty_int | true}  
 _bv2 --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 v --->  {v:Ty_alphalist | (slen)(v) ==((slen)(_bv2) + (1))}  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , 
 	 Conj <c true
 	 , 
 	 Conj <c var_v5 = false
 	 , DoubleImpl 
 var_v5 = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 var_v5 = false
  s > 0 >c  >c  >c  >c 
 	 , true >c 
 	 , (slen)(_bv2) ==(0) >c 
 	 , (slen)(v) ==((slen)(_bv2) + (1)) >c 
 	 ------------------------------
 
        	 CONS => (slen)(v) ==(s) 
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 var_v5 --->  Ty_bool  
 _bv1 --->  Ty_int  
 _bv2 --->  Ty_alphalist  
 v --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Base var_v5 = false AND 
 	 Base var_v5 = true <=> Conj  AND 
 	 Base s = 0 AND 
 	 Base var_v5 = false <=> Base s > 0 AND 
 	 Rel (slen)(_bv2) ==(0) AND 
 	 Rel (slen)(v) ==((slen)(_bv2) + (1)) 
 	 ------------------------

	 CONS Rel (slen)(v) ==(s)
 
VC_END                             
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 Show :: Failed Synthesis False Branch 
  If then else Failed :: Try CDCL without subdivision
 
 Show ***********Calling Scalar synthesize***************
 esynthesizeScalar for {v:Ty_alphalist | (slen)(v) ==(s)}
  Enumeration for 
 spec 
 {v:Ty_alphalist | (slen)(v) ==(s)}
 
 Enumerating a Pure Term nil
 
 Type of the Pure Term {v:Ty_alphalist | (slen)(v) ==(0)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 subs --->  Function type  
 s --->  Ty_int  
 nil --->  Ty_alphalist 
 	 ANTE Rel (slen)(nil) ==(0) 
 	 ------------------------

	 CONS Rel (slen)(nil) ==(s)
 
VC_END
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 goal, 
 cons
 Show Pure Component goal
  *************** Arrow Component ************goal :  Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}
  *************** Synthesizing Args ei : ti for ************goal
 esynthesizeScalar for {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c }
  Enumeration for 
 spec 
 {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c }
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS Base s > s
 
VC_END     
 
 FaileD the subtype check T_vi <: T_goal
 >>>>>>>>>>>>>>>>>> No Scalar found, Trying esynthesizePureApp <<<<<<<<<<<<<<<<<< 
  Pure Fun Application: esynthesizePureApp 
 Show Potential Functions
  , 
 subs
 Show Pure Component subs
  *************** Arrow Component ************subs :  Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}
  *************** Synthesizing Args ei : ti for ************subs
 esynthesizeScalar for {var_v0:Ty_int | true}
  Enumeration for 
 spec 
 {var_v0:Ty_int | true}
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
 Show :: Found a Few Macthing Scalars 
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | true} 
 s 
 }
 Possible Argument Options 
 Next Possible Args 
 EI s
 Apply Single Argument Case : f (ei) Case subs
 Typechecking apply subs  (, s )
 Against {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c }
 Argument s :: {v:Ty_int | true} | true
 AppType {v:Ty_int | (v) ==((s) -- (1))}
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 v --->  {v:Ty_int | (v) ==((s) -- (1))}  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , true >c 
 	 , true >c 
 	 , (v) ==((s) -- (1)) >c 
 	 ------------------------------
 
        	 CONS => 
 	 Conj <c true
 	 , s > v >c  
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 v --->  Ty_int 
 	 ANTE Rel (v) ==((s) -- (1)) 
 	 ------------------------

	 CONS Base s > v
 
VC_END     
  Show *************** TypeChecking Succsessful {v:Ty_int | (v) ==((s) -- (1))}
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | (v) ==((s) -- (1))} 
 apply subs  (, s ) 
 }
 Possible Argument Options 
 Next Possible Args 
 EI apply subs  (, s )
 Apply Single Argument Case : f (ei) Case goal
 Typechecking apply goal  (, _bv3 )
 Against {v:Ty_alphalist | (slen)(v) ==(s)}
 Argument _bv3 :: {v:Ty_int | (v) ==((s) -- (1))} | (_bv3) ==((s) -- (1))
 AppType {v:Ty_alphalist | (slen)(v) ==(_bv3)}
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 _bv3 --->  {v:Ty_int | (v) ==((s) -- (1))}  
 v --->  {v:Ty_alphalist | (slen)(v) ==(_bv3)}  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , true >c 
 	 , (_bv3) ==((s) -- (1)) >c 
 	 , (slen)(v) ==(_bv3) >c 
 	 ------------------------------
 
        	 CONS => (slen)(v) ==(s) 
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 _bv3 --->  Ty_int  
 v --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Rel (_bv3) ==((s) -- (1)) AND 
 	 Rel (slen)(v) ==(_bv3) 
 	 ------------------------

	 CONS Rel (slen)(v) ==(s)
 
VC_END
  FAILED Typechecking PURE APP For apply goal  (, _bv3 )
 Show Pure Component cons
  *************** Arrow Component ************cons :  Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}
  *************** Synthesizing Args ei : ti for ************cons
 esynthesizeScalar for {var_v2:Ty_int | true}
  Enumeration for 
 spec 
 {var_v2:Ty_int | true}
 
 Enumerating a Pure Term s
 
 Type of the Pure Term {v:Ty_int | true}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int 
 	 ANTE True 
 	 ------------------------

	 CONS True
 
VC_END
 Show :: Found a Few Macthing Scalars 
 esynthesizeScalar for {var_v3:Ty_alphalist | true}
  Enumeration for 
 spec 
 {var_v3:Ty_alphalist | true}
 
 Enumerating a Pure Term nil
 
 Type of the Pure Term {v:Ty_alphalist | (slen)(v) ==(0)}
 standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 subs --->  Function type  
 s --->  Ty_int  
 nil --->  Ty_alphalist 
 	 ANTE Rel (slen)(nil) ==(0) 
 	 ------------------------

	 CONS True
 
VC_END
 Show :: Found a Few Macthing Scalars 
  Show *************** Successfully Synthesized Args ei Forall i 
  
 Show Argij { 
{v:Ty_int | true} 
 s 
 }
  
 Show Argij { 
{v:Ty_alphalist | (slen)(v) ==(0)} 
 nil 
 }
 Possible Argument Options 
 Next Possible Args 
 EI s
 EI nil
 Show f (ei, e2, ....en) Case
 Typechecking apply cons  (, _bv4 ), _bv5 )
 Against {v:Ty_alphalist | (slen)(v) ==(s)}
 Argument _bv4 :: {v:Ty_int | true} | true
 Argument _bv5 :: {v:Ty_alphalist | (slen)(v) ==(0)} | (slen)(_bv5) ==(0)
 AppType {v:Ty_alphalist | (slen)(v) ==((slen)(_bv5) + (1))}
  VC VC_BEGIN Gamma MAP 
 
 goal --->   Arrow ( ( s1 : {v:Ty_int | 
 	 Conj <c true
 	 , s > v >c } ) -> {v:Ty_alphalist | (slen)(v) ==(s1)}  
 cons --->   Arrow ( ( x : {var_v2:Ty_int | true} ) ->  Arrow ( ( xs : {var_v3:Ty_alphalist | true} ) -> {v:Ty_alphalist | (slen)(v) ==((slen)(xs) + (1))}  
 sizecheck --->   Arrow ( ( s : {var_v1:Ty_int | true} ) -> {v:Ty_bool | DoubleImpl 
 v = true
  
 	 Conj <c s = 0
 	 , DoubleImpl 
 v = false
  s > 0 >c }  
 nil --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 subs --->   Arrow ( ( n1 : {var_v0:Ty_int | true} ) -> {v:Ty_int | (v) ==((n1) -- (1))}  
 s --->  {v:Ty_int | true}  
 _bv4 --->  {v:Ty_int | true}  
 _bv5 --->  {v:Ty_alphalist | (slen)(v) ==(0)}  
 v --->  {v:Ty_alphalist | (slen)(v) ==((slen)(_bv5) + (1))}  
 	 ANTE 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c 
 	 Conj <c true
 	 , true >c 
 	 , true >c 
 	 , (slen)(_bv5) ==(0) >c 
 	 , (slen)(v) ==((slen)(_bv5) + (1)) >c 
 	 ------------------------------
 
        	 CONS => (slen)(v) ==(s) 
 
        VC_END
 Standardized VC STANDARD VC_BEGIN TyDBINDS  
 
 goal --->  Function type  
 cons --->  Function type  
 sizecheck --->  Function type  
 nil --->  Ty_alphalist  
 subs --->  Function type  
 s --->  Ty_int  
 _bv4 --->  Ty_int  
 _bv5 --->  Ty_alphalist  
 v --->  Ty_alphalist 
 	 ANTE Conj  AND 
 	 Rel (slen)(_bv5) ==(0) AND 
 	 Rel (slen)(v) ==((slen)(_bv5) + (1)) 
 	 ------------------------

	 CONS Rel (slen)(v) ==(s)
 
VC_END
 >>>>>>>>>>>>>>>>>>  No pureApp found, Call esynthesizeConsApp <<<<<<<<<<<<<< 
 Found Constructors with required return type
  
 ********************** HERE BEFORE 
 Show No more choices for ConsApp
 Synthesis returned witout result